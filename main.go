package main

import (
	"bufio"
	"crypto/md5"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/urfave/cli/v2"
	"golang.org/x/term"
)

type Stack struct {
	goroutines []string
	stack      string
}

type StackWrapper struct {
	*Stack
	checksum string
	num      int
}

func Checksum(stack string) string {
	h := md5.New()
	h.Write([]byte(strconv.Itoa(len(stack))))
	h.Write([]byte(strconv.Itoa(strings.Count(stack, "\n"))))
	h.Write([]byte(stack))
	return fmt.Sprintf("%x", h.Sum(nil))
}

func AddStack(goroutine string, stack string, stacks map[string]*Stack) {
	if len(goroutine) == 0 || len(stack) == 0 {
		return
	}
	checksum := Checksum(stack)
	if _, ok := stacks[checksum]; !ok {
		stacks[checksum] = &Stack{goroutines: []string{goroutine}, stack: stack}
	} else {
		stacks[checksum].goroutines = append(stacks[checksum].goroutines, goroutine)
	}
}

func analyze(r io.Reader, w io.Writer) (string, error) {
	cnt := 0
	stacks := make(map[string]*Stack)

	var goroutine string
	stack := make([]string, 0, 32)
	re := regexp.MustCompile(`(0x)(\w+)([?,)}])`)
	gidRe := regexp.MustCompile(`goroutine \d+`)
	buf := bufio.NewScanner(r)
	for {
		if !buf.Scan() {
			if err := buf.Err(); err != nil {
				return "", err
			}
			if len(stack) != 0 {
				AddStack(goroutine, strings.Join(stack, "\n"), stacks)
			}
			break
		}
		line := buf.Text()
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "goroutine ") {
			cnt++
			AddStack(goroutine, strings.Join(stack, "\n"), stacks)
			stack = stack[:0]
			goroutine = strings.TrimSpace(line)
			continue
		}
		line = re.ReplaceAllString(line, "${1}-${2}")
		if strings.HasPrefix(line, "created by ") {
			line = gidRe.ReplaceAllString(line, "goroutine xxx")
		}
		stack = append(stack, line)
	}

	summary := fmt.Sprintf("total goroutines: %d, stack num: %d", cnt, len(stacks))
	fmt.Fprintln(w, summary)

	wrap := make([]StackWrapper, 0, len(stacks))
	for c, s := range stacks {
		wrap = append(wrap, StackWrapper{Stack: s, checksum: c, num: len(s.goroutines)})
	}
	sort.Slice(wrap, func(i, j int) bool { return wrap[i].num > wrap[j].num })
	for _, s := range wrap {
		fmt.Fprintf(w, "\n[stack %s, %d goroutines]:\n%s\n", s.checksum, s.num, s.stack)
	}
	for _, s := range wrap {
		fmt.Fprintf(w, "\n[stack %s, goroutine num: %d]:\n%s\n", s.checksum, s.num, strings.Join(s.goroutines, "\n"))
	}
	return summary, nil
}

func Analyze(fpath string) error {
	fi, err := os.Open(fpath)
	if err != nil {
		return err
	}
	defer fi.Close()

	reportPath := fpath + ".report"
	fo, err := os.Create(reportPath)
	if err != nil {
		return err
	}
	defer fo.Close()

	summary, err := analyze(fi, fo)
	if err != nil {
		return err
	}
	fmt.Printf("\nanalyze %s\n%s\nreport saved to %s\n", fpath, summary, reportPath)
	return nil
}

func main() {
	start := time.Now()
	defer func() {
		fmt.Printf("\nelapsed: %v\n", time.Since(start))
	}()

	app := &cli.App{Name: filepath.Base(os.Args[0])}
	app.Usage = "this is a tool to analyze goroutine stack files which are generated by /debug/pprof/goroutine?debug=2"
	app.UsageText = fmt.Sprintf("%s <stack-file-path>...\nor\ncat <stack-file-path> | %s", app.Name, app.Name)
	app.Action = func(ctx *cli.Context) error {
		// when from pipeline or redirection input
		if !term.IsTerminal(int(os.Stdin.Fd())) {
			_, err := analyze(os.Stdin, os.Stdout)
			return err
		}
		// when from files which are specified by parameters
		for i := range ctx.NArg() {
			fpath, err := filepath.Abs(ctx.Args().Get(i))
			if err != nil {
				return err
			}
			if f, err := os.Stat(fpath); err != nil || f.IsDir() {
				return fmt.Errorf("%s is not an accessible file", fpath)
			}
			if err := Analyze(fpath); err != nil {
				return fmt.Errorf("analyze %s failed: %v", fpath, err)
			}
		}
		return nil
	}

	if err := app.Run(os.Args); err != nil {
		fmt.Println(err)
	}
}
